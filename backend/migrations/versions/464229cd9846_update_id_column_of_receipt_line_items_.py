"""update id column of receipt line items table to string and use uuid as value.

Revision ID: 464229cd9846
Revises: 2b9e6f3a4df1
Create Date: 2025-08-23 16:00:19.736690

"""
from alembic import op
import sqlalchemy as sa
import uuid


# revision identifiers, used by Alembic.
revision = '464229cd9846'
down_revision = '2b9e6f3a4df1'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    
    # Conditionally drop sessions table if it exists
    connection = op.get_bind()
    inspector = sa.inspect(connection)
    if inspector.has_table('sessions'):
        op.drop_table('sessions')
    
    # Create a mapping table to preserve original integer IDs for safe rollback
    op.create_table('receipt_line_items_id_mapping',
        sa.Column('uuid_id', sa.String(length=36), nullable=False),
        sa.Column('original_id', sa.Integer(), nullable=False),
        sa.PrimaryKeyConstraint('uuid_id')
    )
    
    # Store the original integer IDs before changing the column type
    result = connection.execute(sa.text("SELECT id FROM receipt_line_items"))
    for row in result:
        original_id = row[0]
        # Generate a deterministic UUID based on the original ID
        deterministic_uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, f"receipt_line_item_{original_id}"))
        connection.execute(
            sa.text("INSERT INTO receipt_line_items_id_mapping (uuid_id, original_id) VALUES (:uuid_id, :original_id)"),
            {"uuid_id": deterministic_uuid, "original_id": original_id}
        )
    
    # First, change the column type to String to allow UUID values
    with op.batch_alter_table('receipt_line_items', schema=None) as batch_op:
        batch_op.alter_column('id',
               existing_type=sa.INTEGER(),
               type_=sa.String(length=36),
               existing_nullable=False)
    
    # Now update the receipt_line_items table to use the deterministic UUIDs
    result = connection.execute(sa.text("SELECT id FROM receipt_line_items"))
    for row in result:
        original_id = row[0]
        deterministic_uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, f"receipt_line_item_{original_id}"))
        connection.execute(
            sa.text("UPDATE receipt_line_items SET id = :uuid_id WHERE id = :original_id"),
            {"uuid_id": deterministic_uuid, "original_id": str(original_id)}
        )

    with op.batch_alter_table('user_receipts', schema=None) as batch_op:
        batch_op.alter_column('id',
               existing_type=sa.INTEGER(),
               nullable=False,
               autoincrement=True)
        batch_op.alter_column('image_path',
               existing_type=sa.TEXT(),
               type_=sa.String(length=255),
               existing_nullable=True)
        batch_op.alter_column('created_at',
               existing_type=sa.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=True,
               existing_server_default=sa.text('(CURRENT_TIMESTAMP)'))

    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.alter_column('id',
               existing_type=sa.INTEGER(),
               nullable=False,
               autoincrement=True)
        batch_op.alter_column('username',
               existing_type=sa.TEXT(),
               type_=sa.String(length=80),
               existing_nullable=False)
        batch_op.alter_column('email',
               existing_type=sa.TEXT(),
               type_=sa.String(length=120),
               existing_nullable=False)
        batch_op.alter_column('password',
               existing_type=sa.TEXT(),
               type_=sa.String(length=120),
               existing_nullable=False)
        batch_op.alter_column('created_at',
               existing_type=sa.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=True,
               existing_server_default=sa.text('(CURRENT_TIMESTAMP)'))

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    
    # Check if mapping table exists and has data for safe rollback
    connection = op.get_bind()
    inspector = sa.inspect(connection)
    
    # Check if the mapping table exists
    if not inspector.has_table('receipt_line_items_id_mapping'):
        raise RuntimeError(
            "Cannot downgrade: mapping table 'receipt_line_items_id_mapping' not found. "
            "This migration cannot be safely reversed without the mapping table."
        )
    
    # Check if there are any UUIDs in the receipt_line_items table that are not in our mapping
    result = connection.execute(sa.text("""
        SELECT COUNT(*) FROM receipt_line_items rli 
        LEFT JOIN receipt_line_items_id_mapping mapping ON rli.id = mapping.uuid_id 
        WHERE mapping.uuid_id IS NULL
    """))
    unmapped_count = result.scalar()
    
    if unmapped_count > 0:
        raise RuntimeError(
            f"Cannot downgrade: found {unmapped_count} receipt_line_items with UUIDs "
            "that are not in the mapping table. This migration cannot be safely reversed "
            "when new UUIDs have been added after the migration."
        )
    
    # Restore original integer IDs using the mapping table
    result = connection.execute(sa.text("""
        UPDATE receipt_line_items 
        SET id = mapping.original_id 
        FROM receipt_line_items_id_mapping mapping 
        WHERE receipt_line_items.id = mapping.uuid_id
    """))
    
    # Drop the mapping table as it's no longer needed
    op.drop_table('receipt_line_items_id_mapping')
    
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.alter_column('created_at',
               existing_type=sa.DateTime(timezone=True),
               type_=sa.TIMESTAMP(),
               existing_nullable=True,
               existing_server_default=sa.text('(CURRENT_TIMESTAMP)'))
        batch_op.alter_column('password',
               existing_type=sa.String(length=120),
               type_=sa.TEXT(),
               existing_nullable=False)
        batch_op.alter_column('email',
               existing_type=sa.String(length=120),
               type_=sa.TEXT(),
               existing_nullable=False)
        batch_op.alter_column('username',
               existing_type=sa.String(length=80),
               type_=sa.TEXT(),
               existing_nullable=False)
        batch_op.alter_column('id',
               existing_type=sa.INTEGER(),
               nullable=True,
               autoincrement=True)

    with op.batch_alter_table('user_receipts', schema=None) as batch_op:
        batch_op.alter_column('created_at',
               existing_type=sa.DateTime(timezone=True),
               type_=sa.TIMESTAMP(),
               existing_nullable=True,
               existing_server_default=sa.text('(CURRENT_TIMESTAMP)'))
        batch_op.alter_column('image_path',
               existing_type=sa.String(length=255),
               type_=sa.TEXT(),
               existing_nullable=True)
        batch_op.alter_column('id',
               existing_type=sa.INTEGER(),
               nullable=True,
               autoincrement=True)

    with op.batch_alter_table('receipt_line_items', schema=None) as batch_op:
        batch_op.alter_column('id',
               existing_type=sa.String(length=36),
               type_=sa.INTEGER(),
               existing_nullable=False)

    op.create_table('sessions',
    sa.Column('id', sa.TEXT(), nullable=True),
    sa.Column('user_id', sa.INTEGER(), nullable=False),
    sa.Column('created_at', sa.TIMESTAMP(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=True),
    sa.Column('expires_at', sa.TIMESTAMP(), nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###
